<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="HandheldFriendly" content="True"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  
  <title>Make A List View In Angular | Nyasoft</title>
  
    <link rel="alternative" href="/rss2.xml" title="Nyasoft" type="application/atom+xml">
  
  <meta name="description" content="Recently, I’m working on an solution to show vast amount of card in a list and scroll smoothly on this list. Further more, the list should
show a timeline meter on the side to allow user navigate to a">
<meta property="og:type" content="article">
<meta property="og:title" content="Make A List View In Angular">
<meta property="og:url" content="http://nya.io/uncategorized/make-a-list-view-in-angular/index.html">
<meta property="og:site_name" content="Nyasoft">
<meta property="og:description" content="Recently, I’m working on an solution to show vast amount of card in a list and scroll smoothly on this list. Further more, the list should
show a timeline meter on the side to allow user navigate to a">
<meta property="og:image" content="/img/infinite-list-1.jpg">
<meta property="og:image" content="/img/infinite-list-2.jpg">
<meta property="og:image" content="/img/infinite-list-3.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Make A List View In Angular">
<meta name="twitter:description" content="Recently, I’m working on an solution to show vast amount of card in a list and scroll smoothly on this list. Further more, the list should
show a timeline meter on the side to allow user navigate to a">
  <link rel="stylesheet" href="/css/2bb849c6.styles.css">
  <link rel="stylesheet" href="/fancybox/source/jquery.fancybox.css" type="text/css">
  
</head>
<body>
<nav class="navbar">
  <div class="container-full">
    <a class="brand" href="/">Nyasoft</a>

    <div class="collapse">
      <input id="drawer-toggle" type="checkbox" name="drawer-toggle"/>
      <label for="drawer-toggle" id="drawer-toggle-label">
        <i class="fa fa-navicon"></i>
        <span class="action-name">Nyasoft</span>
      </label>
      <label for="drawer-toggle" id="backdrop-button"></label>
      <ul id="drawer-menu" class="nav nav-menu stack">
        <li class="site-homepage">
          <a href="/">Nyasoft</a>
        </li>
        
        <li>
          <a href="/about">About</a>
        </li>
        
        <li>
          <a href="/archives">Archives</a>
        </li>
        
        <li>
          <a href="/projects">Projects</a>
        </li>
        
        <li>
          <a href="/links">Links</a>
        </li>
        
      </ul>
    </div>
    <div class="container hori-nav-menu">
      <ul class="nav nav-menu">
        
        <li>
          <a href="/about">About</a>
        </li>
        
        <li>
          <a href="/archives">Archives</a>
        </li>
        
        <li>
          <a href="/projects">Projects</a>
        </li>
        
        <li>
          <a href="/links">Links</a>
        </li>
        
      </ul>
    </div>
    <div class="corner-container">
      <ul class="nav nav-menu">
        
        <li>
          <a href="/rss2.xml" title="RSS Feed">
            <i class="fa fa-rss"></i>
          </a>
        </li>
        
      </ul>
    </div>
  </div>
</nav>

<div class="container">
  <article class="article-container">
  <a href="/uncategorized/make-a-list-view-in-angular/" class="post-date mobile-meta">
  <time datetime="2017-04-11T06:35:43.000Z">4月 11 2017</time>
</a>
  <div class="article-content">
    <header class="article-header">
      
        

<h1>
  Make A List View In Angular
</h1>


      
    </header>
    <div class="article-entry">
      
        <p>Recently, I’m working on an solution to show vast amount of card in a list and scroll smoothly on this list. Further more, the list should
show a timeline meter on the side to allow user navigate to any position quickly just drag or click the timeline. This feature pose a challenge
to develop a new kind of UI component which able to show any amount of card in screen without impact the performance.</p>
<p>A tradition way to show large amount of data in a list is so called <em>infinite list</em> or <em>lazy loading</em> . A list loads data at 20-30 items per page until user reaches
bottom of the list. then bumps the next page of data and appends to current list. This solution actually contributes to the initial loading
performance but did not too much to the overall scrolling performance. Using this solution, user cannot quickly scroll to the last position of data.
even worse, when you have loaded 2000-3000 items, your tab crashes.</p>
<h2 id="Find_Another_Approach-">Find Another Approach.</h2><p>The reason why <em>lazy loading</em> or traditional <em>infinite list</em> doesn’t work is obvious. As long as you continue added items into your list, those
DOM elements will exists until eats up all of your memory. So this solution is not fit for our requirements.</p>
<p>If you ever have some experience on Android or iOS development. You may find the solution which has developed for a long time. Yes, that’s
ListView (or RecyclerView, GridView) in Android and UITableView in iOS. They both use a similar idea which keep a limited amount of item on
 the fly and trash the view which is out of current viewport. To reduce the performance expense on create new views, they also recycle the
 trashed views and reuse them on demand. So this idea is what I choose for solving this problem.</p>
<h3 id="First,_How_does_this_solution_work?">First, How does this solution work?</h3><p>The core of this solution is only maintaining a limited number of views in the list and keep remove and added necessary views into list when user
scrolling the list. To make this possible we need to know the height of each view before performing a layout to place those views. In Android,
the framework using a measurement procedure, but at web, we don’t have that mechanism, the dimension of an DOM element is control by css along
with the element parent. So measurement on DOM is hard to do, we don’t want to discuss this topic at this article. We use a predefined height
for each row. By doing this, we simplify the calculation of layout.</p>
<p>Another requirement to make this solution possible is we need to know the total number of items of our list. This is usually not much hard to do.
To make things simple, we also make a little change, we have all data loaded once, so we don’t need to write load on demand.</p>
<p>Once we prepared data and container finish its layout, we will get <strong>container height</strong> , <strong>number of rows</strong>, <strong>row height</strong> . these information
 is pretty enough for our list view to render a initial state.</p>
<p><img src="/img/infinite-list-1.jpg" alt="Initial State"></p>
<p>As you can see, our initial state only contains very limited number of elements. This is what we expect, another information we got from
this picture is we have a scrollbar which indicates we have very long content to scroll. we use a straight forward method to calculate the total
height of scroll content by simply multiply row height and item count. Here is the main DOM structure to make this possible.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- infinite-list has a height of 100% viewport height this height will be used to determine how many views to render --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"infinite-list"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- infinite-list-holder has a height of all --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"infinite-list-holder"</span> <span class="attribute">style</span>=<span class="value">"height: 140000px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list-item-example</span>&gt;</span><span class="tag">&lt;/<span class="title">list-item-example</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>infinite-list</code> is the container of visible views, it use a <code>overflow-y: auto</code> css to make the <code>infinite-list-holder</code> scrollable.
When this structure is established, browser will render a scrollbar for <code>infinite-list</code>.</p>
<p>When user scroll down or up, the <code>infinite-list-holder</code> will scroll and together with its view content. meanwhile we listen to the
scroll event to asynchronously calculate how far we have scrolled from initial position.</p>
<p>THE key part of the solution can keep a low memory usage is keep calculating every view position relative to viewport, add views which
 are about to visible in the viewport and remove views which is already out of viewport.</p>
<p><img src="/img/infinite-list-2.jpg" alt="When content scrolling, remove and added views"></p>
<p>This is really very intuitive solution. keep added and remove views as long as there are the right views in our viewport, user will feel
like our list is filled with all of the data items. OK, this is simple. But how do we know which view is out of viewport, which view is
about to add in viewport and how to place them in the correct position.</p>
<h3 id="Do_the_layout">Do the layout</h3><p>we already have some basic information about our container <code>infinite-list</code>, we know its width and height. we also get height of every row
 and total number of data. when we do layout at scrolling, we need one more information to know how much have we scrolled. This is not hard
 to obtain. In all browser, we can use <code>element.scrollTop</code> property to know the relative distance between top of the scrolling content and
  top of the wrapper content. (More detail, you can learn from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop" target="_blank" rel="external">MDN</a>)</p>
<p>Calculate the index of top most view relative to our viewport, remove any views before that index.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstIndex = <span class="built_in">Math</span>.floor(scrollTop / rowHeight);</span><br></pre></td></tr></table></figure>
<p>Calculate the index of bottom most view relative to our viewport, remove any views after that index.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we need this offset to complement the height of viewport. because a view may just cross the border of list-container</span></span><br><span class="line"><span class="keyword">let</span> firstViewOffset = scrollTop - firstIndex * rowHeight;</span><br><span class="line"><span class="comment">// containerHeight is equal to viewport height as we assumed</span></span><br><span class="line"><span class="keyword">let</span> lastIndex = <span class="built_in">Math</span>.ceil((containerHeight + firstViewOffset) / rowHeight) + firstIndex;</span><br></pre></td></tr></table></figure>
<p>Once we get the index range, we can remove view not inside this range and added views according this range. To added view at correct position,
we need calculate its top y coordinate relative the list-holder.
This calculation is more easy. We can calculate a view y position base on row height and data item index:</p>
<p>A view top y position relative to infinite-list-holder is <code>rowHeight * index</code></p>
<p>The method we use to place our views on <code>infinite-list-holder</code> is using css3 translate3d and let each view’s position property be absolute.
By using this method we get the hardware acceleration and not trigger any re-layout out side the <code>infinite-list-holder</code>. This is another
 important performance trick.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">viewElement.style.transform = `translate3d(<span class="number">0</span>, $&#123;y&#125;px, <span class="number">0</span>)`;</span><br><span class="line">viewElement.style.webkitTransform = `translate3d(<span class="number">0</span>, $&#123;y&#125;px, <span class="number">0</span>)`;</span><br><span class="line">viewElement.style.width = `$&#123;containerWidth&#125;px`;</span><br><span class="line">viewElement.style.height = `$&#123;rowHeight&#125;px`;</span><br><span class="line">viewElement.style.position = <span class="string">'absolute'</span>;</span><br></pre></td></tr></table></figure>
<p>Once styles is applied. insert view into <code>infinite-list-holder</code> at proper position, browser will render the view for us.</p>
<p>This process will repeat whenever we need to do a layout operation. At the user aspect, the view will really scroll in the list.</p>
<h3 id="Optimization-">Optimization.</h3><p>So far so good, We have give a smooth scrolling experience to user using our real <strong>infinite-list</strong> .but currently we only create a very
simple example which using a simple structure for item view. What if we have a very complex view to render. we need to rapidly remove and
add DOM element to our list-holder, the view element may have many object to initialize. many listener to add. Creating new object especially
DOM element object is expensive. Those views in our list are very the same structure, the only different is there content. so we decide to
do some optimization to reuse the views.</p>
<p>To reuse view, we need modified our solution at two phase, remove and add phase. At remove phase, we don’t directly destroy that trashed view,
we detach that view and move it into a recycle bin. we can create a class called <code>RecycleBin</code> to manage those recycled views. At add phase, we
 first try to retrieve view from RecycleBin, if we find the same view with the same index we expect, we can directly reattach it back to list-holder,
 because its content is the same. But if we don’t have that type of view, we can also pop a view from scrap views, and replace its binding data
 with correct data at certain index. If you use a MVVM framework, the framework will do the rest things. only when we don’t have scraped views
 from <code>RecycleBin</code>, we create a new view with data of certain index.</p>
<p><img src="/img/infinite-list-3.jpg" alt="RecycleBin"></p>
<p>Our modified version reduce the dom create and destroy, also reduce the new memory allocation and GC operation (though this is really depend
on JS engine). A drawback of this modification is we increase a little more memory usage. But if you can write some simple strategy to control
the total number of scrap views. No need to worry about run out of memory.</p>
<p>So far we have briefly explained how our solution work. But we haven’t explained how to implement in Angular.</p>
<h2 id="The_Angular_Implementation">The Angular Implementation</h2><p><em>we only cover the Angular 4 and above, if you want to find an AngularJS (1.x) implementation. You can read the code from <a href="https://github.com/ngFancy/ng-gridview" target="_blank" rel="external">this repository</a> to see how to
implement this approach in Angular 1.5, although this is grid view which is a little complicated.</em></p>
<p>In Angular, things are not much different. We still use the theory we have explained before plus a little angular feature.</p>
<p>In Angular, there are component and directive ( include structural directive ) which can manipulate DOM as we need. Recall our feature requirement,
Our list, in fact, has repeat structure which presents data in same form repeatedly. The idea flash in your mind first must be ngFor directive which
 is a structural directive can clone its content repeatedly. The difference between ngFor and our directive is ngFor render all DOM in the collection
 we don’t. So we use a similar directive called <code>infiniteFor</code> which has a very same usage.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">any</span> *<span class="attribute">infiniteFor</span>=<span class="value">"let row of collection"</span>&gt;</span></span><br><span class="line">    &#123;&#123;row&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">any</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>By using these semantic we borrowed from ngFor, we can create a local variable binding to its template from the iterable collection
In Angular we don’t have the concept <code>scope</code> but it is a very similar concept which using an object to store your local variable and bind to the template.
We won’t use too much words to describe how ngFor implement. if you don’t understand and have interest in this, you can read official document:
 <a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#!#ngFor" target="_blank" rel="external">Structural Directive</a> and <a href="https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html" target="_blank" rel="external">ngFor API Guide</a></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">@Directive(&#123;</span><br><span class="line">    selector: <span class="string">'[infiniteFor][infiniteForOf]'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> InfiniteForOf&lt;T&gt; <span class="keyword">implements</span> OnChanges, DoCheck &#123;</span><br><span class="line">    <span class="keyword">private</span> _differ: IterableDiffer&lt;T&gt;;</span><br><span class="line">    <span class="keyword">private</span> _trackByFn: TrackByFunction&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a major difference from ngFor directive, we actually need store the whole collection to a data structure (we use array)</span></span><br><span class="line">    <span class="keyword">private</span> _collection: <span class="built_in">any</span>[];</span><br><span class="line"></span><br><span class="line">    @Input() infiniteForOf: NgIterable&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    @Input()</span><br><span class="line">    <span class="keyword">set</span> infiniteForTrackBy(fn: TrackByFunction&lt;T&gt;) &#123;</span><br><span class="line">        <span class="keyword">this</span>._trackByFn = fn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> infiniteForTrackBy(): TrackByFunction&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._trackByFn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Input()</span><br><span class="line">    <span class="keyword">set</span> infiniteForTemplate(value: TemplateRef&lt;InfiniteRow&gt;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>._template = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(private _infiniteList: InfiniteList,</span><br><span class="line">                private _differs: IterableDiffers,</span><br><span class="line">                private _template: TemplateRef&lt;InfiniteRow&gt;,</span><br><span class="line">                private _viewContainerRef: ViewContainerRef) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnChanges(changes: SimpleChanges): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'infiniteForOf'</span> <span class="keyword">in</span> changes) &#123;</span><br><span class="line">            <span class="comment">// React on infiniteForOf only once all inputs have been initialized</span></span><br><span class="line">            <span class="keyword">const</span> value = changes[<span class="string">'infiniteForOf'</span>].currentValue;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>._differ &amp;&amp; value) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>._differ = <span class="keyword">this</span>._differs.find(value).create(<span class="keyword">this</span>._trackByFn);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(`Cannot find a differ supporting object <span class="string">'$&#123;value&#125;'</span> of <span class="keyword">type</span> <span class="string">'$&#123;getTypeNameForDebugging(value)&#125;'</span>. NgFor only supports binding to Iterables such as Arrays.`);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngDoCheck(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._differ) &#123;</span><br><span class="line">            <span class="keyword">const</span> changes = <span class="keyword">this</span>._differ.diff(<span class="keyword">this</span>.infiniteForOf);</span><br><span class="line">            <span class="keyword">if</span> (changes) &#123;</span><br><span class="line">                <span class="keyword">this</span>.applyChanges(changes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> applyChanges(changes: IterableChanges&lt;T&gt;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>._collection) &#123;</span><br><span class="line">            <span class="keyword">this</span>._collection = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> isMeasurementRequired = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        changes.forEachOperation((item: IterableChangeRecord&lt;<span class="built_in">any</span>&gt;, adjustedPreviousIndex: <span class="built_in">number</span>, currentIndex: <span class="built_in">number</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.previousIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// new item</span></span><br><span class="line">                isMeasurementRequired = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>._collection.splice(currentIndex, <span class="number">0</span>, item.item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentIndex == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// remove item</span></span><br><span class="line">                isMeasurementRequired = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">this</span>._collection.splice(adjustedPreviousIndex, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// move item</span></span><br><span class="line">                <span class="keyword">this</span>._collection.splice(currentIndex, <span class="number">0</span>, <span class="keyword">this</span>._collection.splice(adjustedPreviousIndex, <span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        changes.forEachIdentityChange((record: <span class="built_in">any</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._collection[record.currentIndex] = record.item;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isMeasurementRequired) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestMeasure();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Instead of directly react on data changes, we need to store the whole data set into a collection because we may use it later,
But IterableDiffer is still a useful tool to manipulate our data collection without need to learn the actual data structure of source data.
when any changes of data happen, we mark a <code>isMeasurementRequired</code> to determine whether we need to recalculate the list-holder height.
This is needed when we change the size of collection. Whenever a change happen, a layout is requested.</p>
<p>Consider when we should do the layout. By learn the feature of our component, we can find three timing to do layout:</p>
<ul>
<li>After a measurement. (data set size changes, container dimension changes)</li>
<li>scroll event happens.</li>
<li>data changes</li>
</ul>
<p>The actual layout is the core process. we will break it into several parts.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> layout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._isInLayout || !<span class="keyword">this</span>._collection || <span class="keyword">this</span>._collection.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._isInLayout = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123;width, height&#125; = <span class="keyword">this</span>._infiniteList.measure();</span><br><span class="line">    <span class="keyword">this</span>._containerWidth = width;</span><br><span class="line">    <span class="keyword">this</span>._containerHeight = height;</span><br><span class="line">    <span class="keyword">this</span>.findPositionInRange();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._viewContainerRef.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> child = <span class="xml"><span class="tag">&lt;<span class="title">EmbeddedViewRef</span>&lt;<span class="attribute">InfiniteRow</span>&gt;</span>&gt; this._viewContainerRef.get(i);</span><br><span class="line">        this._viewContainerRef.detach(i);</span><br><span class="line">        this._recycler.recycleView(child.context.index, child);</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    this.insertViews();</span><br><span class="line">    this._recycler.pruneScrapViews();</span><br><span class="line">    this._isInLayout = false;</span><br><span class="line">    this._invalidate = false;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>we first check the prerequisites, we should not do layout when:</p>
<ul>
<li>A layout is performing.</li>
<li>Collection is empty.</li>
</ul>
<p>Then update containerHeight because we need this in <code>findPositionInRange</code>,
After we do findPositionInRange( which is actually calculate the first and last index need to be in list-holder). we detach our existed views
in <code>list-holder</code>. and re insert needed views back into it. after all job is done, we also prune the recycle bin to make sure it will not bloat too big.</p>
<p>How we implement findPositionInRange has been explained in the previous section. the start index and end index is exactly follow those formula to calculate.
So the next important thing is adding views back to list-holder. the <code>getView</code> method first try to get views from recycle bin, if not find, create a new EmbeddedView
 with <code>InfiniteRow</code> object, this object is a data structure provide the data and some information like index, count. it has important property <code>$implicit</code> which is used
 by angular core to binding our data to view.</p>
<p>Once we get the view, <code>dispatchLayout</code> method will do the rest job to place views (applyStyle and insert).</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> insertViews() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="keyword">this</span>._firstItemPosition; i &lt;= <span class="keyword">this</span>._lastItemPosition; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> view = <span class="keyword">this</span>.getView(i);</span><br><span class="line">        <span class="keyword">this</span>.dispatchLayout(i, view, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> getView(position: <span class="built_in">number</span>): ViewRef &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="keyword">this</span>._recycler.getView(position);</span><br><span class="line">    <span class="keyword">let</span> item = <span class="keyword">this</span>._collection[position];</span><br><span class="line">    <span class="keyword">let</span> count = <span class="keyword">this</span>._collection.length;</span><br><span class="line">    <span class="keyword">if</span> (!view) &#123;</span><br><span class="line">        view = <span class="keyword">this</span>._template.createEmbeddedView(<span class="keyword">new</span> InfiniteRow(item, position, count));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (view as EmbeddedViewRef&lt;InfiniteRow&gt;).context.$implicit = item;</span><br><span class="line">        (view as EmbeddedViewRef&lt;InfiniteRow&gt;).context.index = position;</span><br><span class="line">        (view as EmbeddedViewRef&lt;InfiniteRow&gt;).context.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> applyStyles(viewElement: HTMLElement, y: <span class="built_in">number</span>) &#123;</span><br><span class="line">    viewElement.style.transform = `translate3d(<span class="number">0</span>, $&#123;y&#125;px, <span class="number">0</span>)`;</span><br><span class="line">    viewElement.style.webkitTransform = `translate3d(<span class="number">0</span>, $&#123;y&#125;px, <span class="number">0</span>)`;</span><br><span class="line">    viewElement.style.width = `$&#123;<span class="keyword">this</span>._containerWidth&#125;px`;</span><br><span class="line">    viewElement.style.height = `$&#123;<span class="keyword">this</span>._infiniteList.rowHeight&#125;px`;</span><br><span class="line">    viewElement.style.position = <span class="string">'absolute'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> dispatchLayout(position: <span class="built_in">number</span>, view: ViewRef, addBefore: <span class="built_in">boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> startPosY = position * <span class="keyword">this</span>._infiniteList.rowHeight;</span><br><span class="line">    <span class="keyword">this</span>.applyStyles((view as EmbeddedViewRef&lt;InfiniteRow&gt;).rootNodes[<span class="number">0</span>], startPosY);</span><br><span class="line">    <span class="keyword">if</span> (addBefore) &#123;</span><br><span class="line">        <span class="keyword">this</span>._viewContainerRef.insert(view, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._viewContainerRef.insert(view);</span><br><span class="line">    &#125;</span><br><span class="line">    view.reattach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We have nearly all done. But because we separate the component into two pieces. we haven’t implement the container component <code>InfiniteList</code>.
It is responsible for listen to scroll event, resize event and set the <code>height</code> to list-holder, it has a simple dom structure:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- infinite-list.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"infinite-list"</span> #<span class="attribute">listContainer</span></span><br><span class="line">     [<span class="attribute">ngClass</span>]=<span class="value">"scrollbarStyle"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"infinite-list-holder"</span> [<span class="attribute">style.height</span>]=<span class="value">"holderHeightInPx"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ng-content</span>&gt;</span><span class="tag">&lt;/<span class="title">ng-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>By using <code>ng-content</code> we can put all element generated by <code>InfiniteForOf</code> directive. The important thing behind the html is a css definition.
We must make infinite-list <code>overflow-y: auto</code> and give it a limit height (if you container element have a height, you can use 100%)</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.infinite-list</span> &#123;</span><br><span class="line">  <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">  <span class="attribute">overflow-x</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">contain</span>: layout;          <span class="comment">// this is performance trick, you can lookup this css property in MDN</span></span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch; <span class="comment">// make a touch scroll has resilient.</span></span><br><span class="line">  <span class="class">.infinite-list-holder</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;     <span class="comment">// relative is also a very important property. because of all its children will be position: absolute;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the InfiniteList class we heavily use the Observable from RxJS, if you are not familiar rxjs, you can find some material from the internet.
 There some important notice when implement this component.</p>
<ul>
<li>Do all DOM event binding in <code>AfterViewInit</code> lifecycle hook. and besides, you should use setTimeout() to trigger a immediate measurement. Because
this operation will change _containerWidth and _containerHeight in one tick which will cause an error in zone.js. so we need to schedule it to next tick.</li>
<li>scrollPosition subject is a BehaviorSubject, it has a convenience that a initial value will be emitted without need the scroll event. This is helpful to
initialize the layout of <code>InfiniteForOf</code>.</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">    selector: <span class="string">'infinite-list'</span>,</span><br><span class="line">    templateUrl: <span class="string">'infinite-list.html'</span>,</span><br><span class="line">    styleUrls: [<span class="string">'infinite-list.less'</span>]</span><br><span class="line">&#125;)</span><br><span class="line">export class InfiniteList implements AfterViewInit, OnDestroy &#123;</span><br><span class="line">    <span class="keyword">private</span> _holderHeight: number;</span><br><span class="line">    <span class="keyword">private</span> _containerWidth: number;</span><br><span class="line">    <span class="keyword">private</span> _containerHeight: number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _subscription: Subscription = <span class="keyword">new</span> Subscription();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _scrollPosition: BehaviorSubject&lt;number&gt; = <span class="keyword">new</span> BehaviorSubject(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> _sizeChange: BehaviorSubject&lt;number[]&gt; = <span class="keyword">new</span> BehaviorSubject([<span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    @ViewChild(<span class="string">'listContainer'</span>) listContainer: ElementRef;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span> holderHeight(<span class="variable">height</span>: number) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">height</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._holderHeight = <span class="variable">height</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span> holderHeight(): number &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._holderHeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get</span> holderHeightInPx(): string &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.holderHeight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.holderHeight + <span class="string">'px'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'100%'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * current scroll position.</span><br><span class="line">     * @type &#123;number&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">get</span> scrollPosition(): Observable&lt;number&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._scrollPosition.asObservable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * list container width and height.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">get</span> sizeChange(): Observable&lt;number[]&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._sizeChange.asObservable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Input() rowHeight: number;</span><br><span class="line"></span><br><span class="line">    ngAfterViewInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (window) &#123;</span><br><span class="line">            <span class="keyword">this</span>._subscription.<span class="built_in">add</span>(Observable.fromEvent(window, <span class="string">'resize'</span>)</span><br><span class="line">                .subscribe(() =&gt; &#123;</span><br><span class="line">                    let &#123;<span class="variable">width</span>, <span class="variable">height</span>&#125; = <span class="keyword">this</span>.measure();</span><br><span class="line">                    <span class="keyword">this</span>._sizeChange.next([<span class="variable">width</span>, <span class="variable">height</span>]);</span><br><span class="line">                &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>._subscription.<span class="built_in">add</span>(Observable.fromEvent(<span class="keyword">this</span>.listContainer.nativeElement, <span class="string">'scroll'</span>)</span><br><span class="line">            .<span class="built_in">map</span>(() =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.listContainer.nativeElement.scrollTop;</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe((scrollY: number) =&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>._scrollPosition.next(scrollY);</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            let &#123;<span class="variable">width</span>, <span class="variable">height</span>&#125; = <span class="keyword">this</span>.measure();</span><br><span class="line">            <span class="keyword">this</span>._sizeChange.next([<span class="variable">width</span>, <span class="variable">height</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnDestroy(): <span class="keyword">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._subscription.unsubscribe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    measure():&#123;<span class="variable">width</span>: number, <span class="variable">height</span>: number&#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.listContainer &amp;&amp; <span class="keyword">this</span>.listContainer.nativeElement) &#123;</span><br><span class="line">            let <span class="built_in">rect</span> = <span class="keyword">this</span>.listContainer.nativeElement.getBoundingClientRect();</span><br><span class="line">            <span class="keyword">this</span>._containerWidth = <span class="built_in">rect</span>.<span class="variable">width</span> - <span class="keyword">this</span>.scrollbarWidth;</span><br><span class="line">            <span class="keyword">this</span>._containerHeight = <span class="built_in">rect</span>.<span class="variable">height</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="variable">width</span>: <span class="keyword">this</span>._containerWidth, <span class="variable">height</span>: <span class="keyword">this</span>._containerHeight&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="variable">width</span>: <span class="number">0</span>, <span class="variable">height</span>: <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By now, we have all done. let’s use our component and directive together to make a list with infinite smooth scroll.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"demo-container"</span> *<span class="attribute">ngIf</span>=<span class="value">"collection"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">infinite-list</span> [<span class="attribute">rowHeight</span>]=<span class="value">"140"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list-item-example</span> *<span class="attribute">infiniteFor</span>=<span class="value">"let row of collection; let i = index"</span> [<span class="attribute">item</span>]=<span class="value">"row"</span> [<span class="attribute">index</span>]=<span class="value">"i"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="title">list-item-example</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">infinite-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In this case, we give the view height 140 to InfiniteList component and pass row local variable to ListItemExample component, the actual list item will
be rendered by <code>ListItemExample</code> component.</p>
<p>The demo can be found at <a href="https://github.com/lordfriend/Deneb-UI/tree/master/demo-app/app/infinite-list" target="_blank" rel="external">GitHub</a>.</p>
<p>The real component has some additional feature which can tell the list item component current scroll state. This will be helpful to make some decision
 when user is performing a fast scroll and avoid unnecessary resource loading.</p>

      
    </div>
  </div>
  <div class="article-additional">
    <div class="social-buttons">
      <a data-url="http://nya.io/uncategorized/make-a-list-view-in-angular/" data-id="cj1vz884d000oeols57pgunf4" class="article-share-link">
        <i class="fa fa-share"></i>
        Share
      </a>
    </div>
    
    
  <ul class="tag-list nav-menu mobile-meta">
    
      <li>
        <a href="/tags/Angular/">#Angular</a>
      </li>
    
      <li>
        <a href="/tags/InfiniteList/">#InfiniteList</a>
      </li>
    
      <li>
        <a href="/tags/ListView/">#ListView</a>
      </li>
    
      <li>
        <a href="/tags/Performance/">#Performance</a>
      </li>
    
  </ul>

  </div>
  <div class="article-meta">
    <a href="/uncategorized/make-a-list-view-in-angular/" class="post-date">
  <time datetime="2017-04-11T06:35:43.000Z">4月 11 2017</time>
</a>
    
    
  <ul class="tag-list">
    
      <li>
        <a href="/tags/Angular/">#Angular</a>
      </li>
    
      <li>
        <a href="/tags/InfiniteList/">#InfiniteList</a>
      </li>
    
      <li>
        <a href="/tags/ListView/">#ListView</a>
      </li>
    
      <li>
        <a href="/tags/Performance/">#Performance</a>
      </li>
    
  </ul>

  </div>
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>

<footer class="footer">
  <div class="container">
    <div class="footer-inner">

      <section class="copyright">
        Nyasoft © 2015
      </section>

      <section class="designedby">
        Theme
        <a href="#">Timeline</a>
        Designed By
        Nyasoft
      </section>

      <section class="poweredby">
        Powered By
        <a href="http://hexo.io/">Hexo</a>
      </section>
    </div>
  </div>
</footer>


<script>
  var disqus_shortname = 'lordfriend';
  
  var disqus_url = 'http://nya.io/uncategorized/make-a-list-view-in-angular/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script type="text/javascript" src="/js/cf26f8f0.jquery.js"></script>
<script src="/fancybox/source/jquery.fancybox.js" type="text/javascript"></script>
<script type="text/javascript" src="/js/33415e49.caption.js"></script>
</body>